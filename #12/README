由于本代码功能较为复杂（基于先能跑就行的凑合思想。。。），而程序各功能间耦合度较高，为了提高可读性，故撰写此文档（要是没有这个我估计没人能看的懂吧。。。）

1.程序使用
1.1 基本操作逻辑
	本程序我个人认为算是一个简陋的绘图器，有5个功能：打点/画线/画矩形/输入文字/清屏
	按数字键1～5进入功能，ESC退出，回车确认（打点和清屏因为只有一步所以无需确认，直接生效）
	Ctrl C退出程序
	方向键上下左右移动光标（还有一点不影响使用的故障，比如同时按下多个按键之后松开其中几个会出现判定失误的问题，但完全松开后一定会停止）
1.2 打点
	按下1在光标正中央留下一个天蓝色的点
1.3 画线
	按下2在光标处设定为直线起点，然后可以移动光标，以最可能的近似方向作为直线的终点（因为想了好久没想好直线的抗锯齿，加上任务没有要求，就没实现斜线的显示），按回车确认
1.4 画矩形
	按下3设定第一个点，移动光标后回车确定第二个点，以两个点确定一个矩形
1.5 输入文字
	按下4进入输入模式，按下任意字母即打印到屏幕上，同时自动移动光标，最后一个字母如果需要打印按回车确认，不需要按ESC退出
1.6 清屏
	按下5立即清屏

2.代码简单解释
1.1 基本介绍
	整个程序的大致思路是用已知的方法获取输入和显存，然后用一个死循环不断根据状态刷新屏幕。
1.2 全局变量介绍
	存储屏幕大小的结构体/显存/与显存相对应的几个内存缓冲/显示文件描述符/跟文本输入相关的两个参数
1.3 全局函数介绍
	fb_init
		初始化显存映射，并把屏幕大小存进box结构体
	clear_buffer
		清屏
	full_xy_area
		绘制矩形
	full_xy_line
		绘制线
	out_code
		把按键的键盘code转换为ASCII码
	get_font
		根据编号从_font.h中获取对应的字体
	print_a_word
		根据字体和缩放参数显示字符
	codeToNo
		根据ASCII码换算为字体文件中的编号
1.4 main函数介绍
	变量
		ij为循环变量，之后是打开的文件编号/按键标记数/功能标记/状态标记/字体编号/ASCII码存储用临时变量
		输入事件
		光标坐标/光标移动量/一个点/另一个点/坐标为零的点
	内容
		根据顺序介绍，首先是三个屏幕缓冲区。这是由于我发现绘制光标的时候一旦移动光标，就需要清除原来的光标，不然就会变成类似画笔的效果，此时我想到了PS的图层概念，便把不同的移动对象放在不同的图层，只不过此处的所谓图层每一层都是下面各层的盖印。大致的顺序是screen_buffer复制到draw_buffer处理完再复制到new_buffer最后再处理。有的功能只需要两步。
		然后设定光标居中
		清屏后进入死循环
		死循环中主要是两个部分，第一个是根据状态和功能决定向缓冲区写什么内容，另一个是根据按键输入决定状态与功能。剩下的是一些边界条件和绘制光标
		然后是终止条件，但因为这个程序为了避免对系统产生不可预知的输入和命令执行，需要使用Ctrl C退出，所以循环后的部分其实没有被执行。
